clear all
close all
clc

num_reps = 12;
gap_size = 3.5;
small_radius = 4.5;
large_radius = 7.5;
extension_half_height = 5;
xy_radius = 45/2 - small_radius;
extra = xy_radius * tan(pi / num_reps) - 3*gap_size/2;
offset = xy_radius - large_radius - (gap_size/2) / tan(pi / num_reps);

screw_radius = 2.2;
nut_height = 3.6;
nut_radius_small = 4.2 / cos(pi/6);
nut_radius_large = 4.4 / cos(pi/6);
screw_min_z = -large_radius - extension_half_height;
screw_max_z = large_radius + extension_half_height - nut_height;

resolution = 0.25;

innerCircle = @(theta) [...
    xy_radius + small_radius * cos(theta) ...
    zeros(size(theta)) ...
    small_radius * sin(theta)];

innerCylinder = @(theta, y) [...
    xy_radius + small_radius * cos(theta) ...
    y ...
    small_radius * sin(theta)];
    
innerCylinderConn = @(z, y) [...
    xy_radius + small_radius * ones(size(z)) ...
    y ...
    z];
    
outerCylinder = @(theta, y) [...
    xy_radius + large_radius * cos(theta) ...
    y ...
    extension_half_height + large_radius * sin(theta)];
    
outerCylinderConn  = @(z, y) [...
    xy_radius + large_radius * ones(size(z)) ...
    y ...
    z];
    
annulus = @(theta, r) [...
    xy_radius + r .* cos(theta) ...
    zeros(size(theta)) ...
    extension_half_height + r .* sin(theta)];
    
annulusConn = @(z, r) [...
    xy_radius + r .* ones(size(z)) ...
    zeros(size(z)) ...
    z];
    
xy_rect = @(x, y) [...
    x ...
    y ...
    zeros(size(x))];
    
xz_rect = @(x, z) [...
    x ...
    zeros(size(x)) ...
    z];
    
yz_rect = @(y, z) [...
    zeros(size(y)) ...
    y ...
    z];

fid = fopen('mug_rim_pusher.stl','wt');
fprintf(fid, 'solid mug_rim_pusher\n');

% inner cylinder
n_theta_divs = 4 * ceil(0.5 * pi * large_radius / resolution);
n_y_divs = 2 * ceil(0.5 * gap_size / resolution);
verticesA = generate_quad_surface(innerCylinder, ...
  0, pi/2, n_theta_divs/4, ...
  -gap_size/2, gap_size/2, n_y_divs);
verticesA = [verticesA;...
  xy_radius-large_radius-offset  gap_size/2 large_radius;...
  xy_radius-large_radius-offset -gap_size/2 large_radius;...
  xy_radius                      gap_size/2 small_radius;...
  xy_radius-large_radius-offset -gap_size/2 large_radius;...
  xy_radius                     -gap_size/2 small_radius;...
  xy_radius                      gap_size/2 small_radius;...
  xy_radius-large_radius-offset  gap_size/2 large_radius;...
  xy_radius                      gap_size/2 small_radius;...
  xy_radius                      gap_size/2 large_radius;...
  xy_radius-large_radius-offset -gap_size/2 large_radius;...
  xy_radius                     -gap_size/2 large_radius;...
  xy_radius                     -gap_size/2 small_radius;...
  xy_radius-large_radius-offset  gap_size/2 large_radius;...
  xy_radius                      gap_size/2 large_radius;...
  xy_radius                      (3*gap_size/2+extra) large_radius;...
  xy_radius                     -gap_size/2 large_radius;...
  xy_radius-large_radius-offset -gap_size/2 large_radius;...
  xy_radius                     -(3*gap_size/2+extra) large_radius;...
  ];
verticesA(:,3) = verticesA(:,3) + extension_half_height;
% flip over z and append
verticesA2 = verticesA;
verticesA2(:,3) = -verticesA2(:,3);
verticesA2 = orientation_flip(verticesA2);
verticesA = [verticesA; verticesA2];
verticesA = [verticesA;...
  xy_radius-large_radius-offset  gap_size/2 -large_radius-extension_half_height;...
  xy_radius-large_radius-offset -gap_size/2 -large_radius-extension_half_height;...
  screw_radius                   0          -large_radius-extension_half_height;...
  xy_radius-large_radius-offset -gap_size/2 large_radius+extension_half_height;...
  xy_radius-large_radius-offset  gap_size/2 large_radius+extension_half_height;...
  nut_radius_large               0          large_radius+extension_half_height;...
  xy_radius-large_radius-offset -gap_size/2 large_radius+extension_half_height;...
  nut_radius_large               0          large_radius+extension_half_height;...
  nut_radius_large*cos(2*pi/num_reps) -nut_radius_large*sin(2*pi/num_reps) large_radius+extension_half_height;...
];

% Add inner connecting surface
verticesA = [verticesA; ...
  generate_quad_surface(innerCylinderConn, ...
    -extension_half_height, extension_half_height, 1, ...
    -gap_size/2, gap_size/2, n_y_divs)];

% outer cylinder
verticesB = generate_quad_surface(outerCylinder, ...
  0, pi/2, n_theta_divs/2, ...
  gap_size/2, (3*gap_size/2+extra), n_y_divs);
% flip over z and append
verticesB2 = verticesB;
verticesB2(:,3) = -verticesB2(:,3);
verticesB2 = orientation_flip(verticesB2);
verticesB = [verticesB; verticesB2];
% Add outer connecting surface
verticesB = [verticesB; ...
  generate_quad_surface(outerCylinderConn, ...
    -extension_half_height, extension_half_height, 1, ...
    gap_size/2, (3*gap_size/2+extra), n_y_divs)];
% flip over y and append
verticesB2 = verticesB;
verticesB2(:,2) = -verticesB2(:,2);
verticesB2 = orientation_flip(verticesB2);
verticesB = [verticesB; verticesB2];

% annuli
n_r_divs = ceil((large_radius - small_radius) / resolution);
verticesC = generate_quad_surface(annulus, ...
  0, pi/2, n_theta_divs/2, ...
  small_radius, large_radius, n_r_divs);
% flip over z and append
verticesC1 = verticesC;
verticesC1(:,3) = -verticesC1(:,3);
verticesC1 = orientation_flip(verticesC1);
verticesC = [verticesC; verticesC1];
% Add connecting surface
verticesC = [verticesC; ...
  generate_quad_surface(annulusConn, ...
    -extension_half_height, extension_half_height, 1, ...
    small_radius, large_radius, n_r_divs)];



verticesC1 = verticesC;
verticesC1(:,2) = gap_size/2;
##verticesC2 = verticesC;
##verticesC2(:,2) = -(3*gap_size/2+extra);
verticesC3 = verticesC;
verticesC3(:,2) = -gap_size/2;
verticesC3 = orientation_flip(verticesC3);
##verticesC4 = verticesC;
##verticesC4(:,2) = (3*gap_size/2+extra);
##verticesC4 = orientation_flip(verticesC4);

verticesC = [verticesC1; verticesC3];

##% half-circles
##verticesD = generate_fan(innerCircle, -pi/2, pi/2, n_theta_divs/2, [xy_radius 0 0]);
##verticesD2 = verticesD;
##verticesD2(:,2) = -(3*gap_size/2+extra);
##verticesD3 = verticesD;
##verticesD4 = verticesD;
##verticesD4(:,2) = (3*gap_size/2+extra);
##verticesD4 = orientation_flip(verticesD4);
##verticesD = [verticesD2; verticesD4];

% Add crescent moon shaped surface
theta = linspace(-pi/2, 0, n_theta_divs/4 + 1)';
pts1 = [...
    xy_radius + large_radius * cos(theta) ...
    (3*gap_size/2+extra) * ones(size(theta)) ...
    -extension_half_height + large_radius * sin(theta)];
% flip over z and append
pts1f = pts1;
pts1f(:,3) = -pts1f(:,3);
pts1f = flipud(pts1f); % also reverse the order
pts1 = [pts1; pts1f];    
pts2 = pts1;
pts2(:,2) = -(3*gap_size/2+extra);
pts2(:,1:2) = pts2(:,1:2) * ...
    [ cos(2*pi/num_reps) sin(2*pi/num_reps); ...
     -sin(2*pi/num_reps) cos(2*pi/num_reps)];
pts1A = pts1(1:end-1,:);
pts1B = pts1(2:end,:);
pts2A = pts2(1:end-1,:);
pts2B = pts2(2:end,:);
verticesD = zeros(6 * size(pts1A,1),3);
verticesD(1:6:end,:) = pts1A;
verticesD(2:6:end,:) = pts1B;
verticesD(3:6:end,:) = pts2B;
verticesD(4:6:end,:) = pts2B;
verticesD(5:6:end,:) = pts2A;
verticesD(6:6:end,:) = pts1A;
verticesD = orientation_flip(verticesD);

##% fan fillers
##verticesE = generate_fan(innerCircle, pi/2, pi, n_theta_divs/2, [xy_radius-small_radius 0 small_radius]);
##verticesE1 = verticesE;
##verticesE1(:,2) = gap_size/2;
##verticesE1 = orientation_flip(verticesE1);
##verticesE2 = verticesE;
##verticesE2(:,2) = -gap_size/2;
##verticesE1 = [verticesE1; verticesE2];
##verticesE2 = verticesE1;
##verticesE2(:,3) = -verticesE2(:,3);
##verticesE2 = orientation_flip(verticesE2);
##
##verticesE = [verticesE1; verticesE2];

##% rectangles
##verticesF = generate_quad_surface(xz_rect, ...
##  xy_radius-small_radius, xy_radius, 1, ...
##  small_radius, large_radius, 1);
####verticesF = [verticesF; ...
####  generate_quad_surface(xz_rect, ...
####  xy_radius-large_radius-offset, xy_radius-small_radius, 1, ...
####  0, large_radius, 1)];
##verticesF(:,2) = -gap_size/2;
##
##verticesF = [verticesF;
##  xy_radius-large_radius-offset gap_size/2 large_radius;
##  xy_radius gap_size/2 large_radius
##  xy_radius (3*gap_size/2+extra) large_radius
##];
##
####temp_rect = generate_quad_surface(yz_rect, ...
####  gap_size/2, (3*gap_size/2+extra), 1, ...
####  0, large_radius, 1);
####temp_rect(:,1) = xy_radius-large_radius-offset;
####verticesF = [verticesF; temp_rect];
##
##verticesF1 = verticesF;
##verticesF2 = verticesF;
##
##verticesF2 = verticesF1;
##verticesF2(:,2) = -verticesF2(:,2);
##verticesF2 = orientation_flip(verticesF2);
##
##verticesF1 = [verticesF1; verticesF2];
##verticesF2 = verticesF1;
##verticesF2(:,3) = -verticesF2(:,3);
##verticesF2 = orientation_flip(verticesF2);
##
##verticesF = [verticesF1; verticesF2];

screwCircle = @(theta) [...
    screw_radius * cos(theta) ...
    screw_radius * sin(theta) ...
    screw_min_z * ones(size(theta)) ...
    ];
n_theta_divs = 12 * ceil(pi * screw_radius / (6 * resolution));
verticesG = generate_fan(screwCircle, 0, pi/3, n_theta_divs/6, ...
    [xy_radius-large_radius-offset  gap_size/2 -large_radius-extension_half_height]);

vertices = [verticesA; verticesB; verticesC; verticesD; verticesG];

for i=0:num_reps-1
  theta_extra = 2*pi*i/num_reps;
  newVertices = vertices;
  newVertices(:,1:2) = newVertices(:,1:2) * ...
    [cos(theta_extra) -sin(theta_extra); ...
     sin(theta_extra) cos(theta_extra)];
  for f = 1:(size(newVertices,1)/3)
    fprintf(fid, 'facet normal 0.0 0.0 1.0\n');
    fprintf(fid, '    outer loop\n');
    fprintf(fid, '        vertex %.3f %.3f %.3f\n', newVertices(3*f-2,:));
    fprintf(fid, '        vertex %.3f %.3f %.3f\n', newVertices(3*f-1,:));
    fprintf(fid, '        vertex %.3f %.3f %.3f\n', newVertices(3*f,:));
    fprintf(fid, '    endloop\n');
    fprintf(fid, 'endfacet\n');
  endfor
endfor

screwCircle = @(theta) [...
    screw_radius * cos(theta) ...
    screw_radius * sin(theta) ...
    screw_max_z * ones(size(theta)) ...
    ];
vertices = generate_fan(screwCircle, pi/6, -pi/6, n_theta_divs/6, [nut_radius_small 0 screw_max_z]);
vertices = [vertices;...
  screw_radius*cos(2*pi/num_reps) screw_radius*sin(2*pi/num_reps) screw_max_z; ...
  nut_radius_small 0 screw_max_z; ...
  nut_radius_small*cos(4*pi/num_reps) nut_radius_small*sin(4*pi/num_reps) screw_max_z; ...
  nut_radius_large 0 large_radius+extension_half_height; ...
  nut_radius_large*cos(2*pi/num_reps) nut_radius_large*sin(2*pi/num_reps) large_radius+extension_half_height; ...
  nut_radius_large*cos(4*pi/num_reps) nut_radius_large*sin(4*pi/num_reps) large_radius+extension_half_height; ...
];

%

for i=0:num_reps/2-1
  theta_extra = 4*pi*i/num_reps;
  newVertices = vertices;
  newVertices(:,1:2) = newVertices(:,1:2) * ...
    [cos(theta_extra) -sin(theta_extra); ...
     sin(theta_extra) cos(theta_extra)];
  for f = 1:(size(newVertices,1)/3)
    fprintf(fid, 'facet normal 0.0 0.0 1.0\n');
    fprintf(fid, '    outer loop\n');
    fprintf(fid, '        vertex %.3f %.3f %.3f\n', newVertices(3*f-2,:));
    fprintf(fid, '        vertex %.3f %.3f %.3f\n', newVertices(3*f-1,:));
    fprintf(fid, '        vertex %.3f %.3f %.3f\n', newVertices(3*f,:));
    fprintf(fid, '    endloop\n');
    fprintf(fid, 'endfacet\n');
  endfor
endfor

screwCylinder = @(theta, z) [...
    screw_radius * cos(theta) ...
    screw_radius * sin(theta) ...
    z ...
    ];
verticesG = generate_cylindrical_surface(screwCylinder, ...
    0, 2*pi, n_theta_divs, ...
    screw_max_z, screw_min_z, 1);
nutCylinder = @(theta, z) [...
    repmat(nut_radius_large + (nut_radius_large - nut_radius_small) / nut_height * ...
    (z - large_radius - extension_half_height),1,2) .* [cos(theta) sin(theta)] ...
    z ...
    ];
verticesG2 = generate_cylindrical_surface(nutCylinder, ...
    0, 2*pi, 6, ...
    large_radius + extension_half_height, large_radius + extension_half_height - nut_height, 1);
verticesG = [verticesG; verticesG2];

for f = 1:(size(verticesG,1)/3)
  fprintf(fid, 'facet normal 0.0 0.0 1.0\n');
  fprintf(fid, '    outer loop\n');
  fprintf(fid, '        vertex %.3f %.3f %.3f\n', verticesG(3*f-2,:));
  fprintf(fid, '        vertex %.3f %.3f %.3f\n', verticesG(3*f-1,:));
  fprintf(fid, '        vertex %.3f %.3f %.3f\n', verticesG(3*f,:));
  fprintf(fid, '    endloop\n');
  fprintf(fid, 'endfacet\n');
endfor

fprintf(fid, 'endsolid mug_rim_pusher\n');
fclose(fid)